#!/usr/bin/env python3
# ESP32 Smart Car Dashboard (Tkinter)
# ✅ Real Serial data + Turn Signal Control
# Usage:
#   pip install pyserial
#   python smart_dash_dashboard.py

import os, sys, json, time, math, threading, queue, csv
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext

try:
    import serial, serial.tools.list_ports
    HAS_SERIAL = True
except Exception:
    HAS_SERIAL = False

BAUD = 115200

# ================= Helper =================
def human(v, fmt="{:.2f}"):
    try:
        if v is None:
            return "—"
        if isinstance(v, (float, int)):
            if math.isnan(float(v)):
                return "—"
            return fmt.format(v)
        return str(v)
    except Exception:
        return str(v)

# ================= Serial Reader =================
class SerialReader(threading.Thread):
    def __init__(self, port, baud, out_q, stop_evt):
        super().__init__(daemon=True)
        self.port = port
        self.baud = baud
        self.q = out_q
        self.stop = stop_evt
        self.buf = b""
        self.ser = None

    def run(self):
        try:
            self.ser = serial.Serial(self.port, self.baud, timeout=0.5)
            self.q.put({"__info__": f"Opened {self.port} @ {self.baud}"})
            while not self.stop.is_set():
                chunk = self.ser.read(256)
                if not chunk:
                    continue
                self.buf += chunk
                while b"\n" in self.buf:
                    line, self.buf = self.buf.split(b"\n", 1)
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        pkt = json.loads(line.decode("utf-8", errors="ignore"))
                        self.q.put(pkt)
                    except Exception:
                        try:
                            s = line.decode("utf-8", errors="ignore")
                        except Exception:
                            s = repr(line)
                        self.q.put({"__raw__": s})
        except Exception as e:
            self.q.put({"__error__": f"Serial open/read error: {e}"})
        finally:
            try:
                if self.ser and self.ser.is_open:
                    self.ser.close()
            except Exception:
                pass
            self.q.put({"__info__": "Serial reader stopped"})

# ================= Speed Gauge =================
class GaugeCanvas(tk.Canvas):
    def __init__(self, parent, width=360, height=180, max_speed=180, **kwargs):
        super().__init__(parent, width=width, height=height, bg="#151515", highlightthickness=0, **kwargs)
        self.width = width
        self.height = height
        self.max_speed = max_speed
        self.center_x = width // 2
        self.center_y = int(height * 1.05)
        self.radius = min(self.width, self.height * 2) * 0.9 / 2
        self.create_arc_bg()
        self.needle = None
        self.create_scale_marks()

    def create_arc_bg(self):
        self.create_arc(
            self.center_x - self.radius,
            self.center_y - self.radius,
            self.center_x + self.radius,
            self.center_y + self.radius,
            start=180, extent=180, style="arc", width=28, outline="#333"
        )

    def create_scale_marks(self):
        for i in range(0, 11):
            angle = math.pi * (1 - i / 10.0)
            x1 = self.center_x + (self.radius - 10) * math.cos(angle)
            y1 = self.center_y - (self.radius - 10) * math.sin(angle)
            x2 = self.center_x + (self.radius - 30) * math.cos(angle)
            y2 = self.center_y - (self.radius - 30) * math.sin(angle)
            self.create_line(x1, y1, x2, y2, fill="#aaa", width=2)
            val = int(self.max_speed * (i / 10.0))
            tx = self.center_x + (self.radius - 50) * math.cos(angle)
            ty = self.center_y - (self.radius - 50) * math.sin(angle)
            self.create_text(tx, ty, text=str(val), fill="#ddd", font=("Segoe UI", 10))

    def set_speed(self, speed):
        speed = max(0.0, min(self.max_speed, speed))
        angle = math.pi * (1 - (speed / self.max_speed))
        x = self.center_x + (self.radius - 40) * math.cos(angle)
        y = self.center_y - (self.radius - 40) * math.sin(angle)
        if self.needle:
            self.delete(self.needle)
        self.needle = self.create_line(self.center_x, self.center_y, x, y, fill="#ff4d4d", width=4)
        self.create_oval(self.center_x - 6, self.center_y - 6, self.center_x + 6, self.center_y + 6, fill="#ddd", outline="")

# ================= Dashboard GUI =================
class DashboardApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Smart Car Dashboard - ESP32 Serial + Turn Signal")
        self.geometry("1150x680")
        self.configure(bg="#151515")
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        self.q = queue.Queue()
        self.stop_evt = threading.Event()
        self.reader_thread = None
        self.csvw = None
        self.logfp = None

        self.create_topbar()
        self.create_main_area()
        self.create_console_area()

        self.after(80, self._poll_queue)

        if HAS_SERIAL:
            self.port_var.set(self.default_port_guess())

    def default_port_guess(self):
        ports = [p.device for p in serial.tools.list_ports.comports()] if HAS_SERIAL else []
        if sys.platform.startswith("win"):
            return ports[0] if ports else ""
        for p in ports:
            if any(tok in p for tok in ("ttyUSB", "ttyACM", "usbserial", "usbmodem")):
                return p
        return ports[0] if ports else ""

    def create_topbar(self):
        top = ttk.Frame(self, padding=8)
        top.pack(fill="x", side="top")

        left = ttk.Frame(top)
        left.pack(side="left", padx=6)
        ttk.Label(left, text="Port:", foreground="#ddd").pack(side="left")
        self.port_var = tk.StringVar(value="")
        self.port_combo = ttk.Combobox(left, textvariable=self.port_var, width=18, values=self.list_ports())
        self.port_combo.pack(side="left", padx=(6, 8))
        ttk.Button(left, text="Refresh", command=self._refresh_ports).pack(side="left", padx=4)
        ttk.Button(left, text="Connect", command=self._on_connect).pack(side="left", padx=4)
        ttk.Button(left, text="Disconnect", command=self._on_disconnect).pack(side="left", padx=4)

        # === Turn Signal Buttons ===
        turn_frame = ttk.Frame(top)
        turn_frame.pack(side="left", padx=20)
        ttk.Button(turn_frame, text="← Xi nhan Trái", command=self._turn_left).pack(side="left", padx=4)
        ttk.Button(turn_frame, text="Xi nhan Phải →", command=self._turn_right).pack(side="left", padx=4)

        right = ttk.Frame(top)
        right.pack(side="right", padx=6)
        ttk.Button(right, text="Start Log", command=self._start_log).pack(side="left", padx=6)
        ttk.Button(right, text="Stop Log", command=self._stop_log).pack(side="left", padx=6)

    def create_main_area(self):
        main = ttk.Frame(self, padding=8)
        main.pack(fill="both", expand=True)
        leftcol = ttk.Frame(main)
        leftcol.pack(side="left", fill="both", expand=True)
        self.gauge = GaugeCanvas(leftcol, width=520, height=260, max_speed=160)
        self.gauge.pack(padx=12, pady=(8, 4))
        self.spd_label = tk.Label(leftcol, text="0.00 km/h", font=("Segoe UI", 36, "bold"), fg="#ffdf6e", bg="#151515")
        self.spd_label.pack(pady=(6, 12))

        rightcol = ttk.Frame(main)
        rightcol.pack(side="right", fill="y", padx=12)
        gps_card = self._make_card(rightcol, "GPS")
        self.gps_speed_var = tk.StringVar(value="—")
        self._add_card_row(gps_card, "Speed (km/h)", self.gps_speed_var)
        self.gps_sats_var = tk.StringVar(value="—")
        self._add_card_row(gps_card, "Satellites", self.gps_sats_var)
        self.gps_lat_var = tk.StringVar(value="—")
        self._add_card_row(gps_card, "Latitude", self.gps_lat_var)
        self.gps_lon_var = tk.StringVar(value="—")
        self._add_card_row(gps_card, "Longitude", self.gps_lon_var)

        env_card = self._make_card(rightcol, "Environment")
        self.temp_var = tk.StringVar(value="—")
        self._add_card_row(env_card, "Temp (°C)", self.temp_var)
        self.hum_var = tk.StringVar(value="—")
        self._add_card_row(env_card, "Humidity (%)", self.hum_var)
        self.mq_v_var = tk.StringVar(value="—")
        self._add_card_row(env_card, "MQ135 V", self.mq_v_var)
        self.mq_raw_var = tk.StringVar(value="—")
        self._add_card_row(env_card, "MQ135 raw", self.mq_raw_var)

        dist_card = self._make_card(rightcol, "Distance")
        self.dist_var = tk.StringVar(value="—")
        self._add_card_row(dist_card, "HC-SR04 (cm)", self.dist_var)

    def _make_card(self, parent, title):
        f = ttk.Frame(parent, padding=(8, 8))
        f.pack(fill="x", pady=8)
        ttk.Label(f, text=title, font=("Segoe UI", 11, "bold")).pack(anchor="w")
        return f

    def _add_card_row(self, parent, label_text, var):
        row = ttk.Frame(parent)
        row.pack(fill="x", pady=2)
        ttk.Label(row, text=label_text + ":", width=18).pack(side="left")
        ttk.Label(row, textvariable=var, width=18).pack(side="left")

    def create_console_area(self):
        frm = ttk.Frame(self, padding=8)
        frm.pack(fill="x", side="bottom")
        ttk.Label(frm, text="Console / Raw").pack(anchor="w")
        self.console = scrolledtext.ScrolledText(frm, height=7, bg="#0f0f0f", fg="#d6d6d6")
        self.console.pack(fill="x")
        self.console.configure(state="disabled", font=("Consolas", 10))

    def list_ports(self):
        if not HAS_SERIAL:
            return []
        return [p.device for p in serial.tools.list_ports.comports()]

    def _refresh_ports(self):
        self.port_combo["values"] = self.list_ports()

    def _on_connect(self):
        if not HAS_SERIAL:
            messagebox.showwarning("pyserial", "pyserial not installed.")
            return
        if getattr(self, "reader_thread", None) and self.reader_thread.is_alive():
            self._log("Already connected.")
            return
        port = self.port_var.get().strip()
        if not port:
            messagebox.showwarning("Select port", "Choose a serial port first.")
            return
        self.stop_evt.clear()
        self.reader_thread = SerialReader(port, BAUD, self.q, self.stop_evt)
        self.reader_thread.start()
        self._log(f"Connecting to {port} @ {BAUD}")

    def _on_disconnect(self):
        self.stop_evt.set()
        self.reader_thread = None
        self._log("Disconnect requested.")

    # ================= Turn Signal Commands =================
    def _send_command(self, cmd):
        """Gửi lệnh xuống ESP32 qua Serial"""
        try:
            if self.reader_thread and self.reader_thread.ser and self.reader_thread.ser.is_open:
                self.reader_thread.ser.write((cmd + "\n").encode("utf-8"))
                self._log(f"Sent: {cmd}")
            else:
                self._log("Serial not connected.")
        except Exception as e:
            self._log(f"Send error: {e}")

    def _turn_left(self):
        self._send_command("TURN_LEFT")

    def _turn_right(self):
        self._send_command("TURN_RIGHT")

    # ================= Logging =================
    def _start_log(self):
        if self.csvw:
            self._log("Already logging.")
            return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV","*.csv")])
        if not path:
            return
        try:
            self.logfp = open(path, "w", newline="", encoding="utf-8")
            self.csvw = csv.writer(self.logfp)
            self.csvw.writerow(["ts","spd_kmh","gps_spd_kmh","lat","lon","alt","sats",
                                "temp_c","hum_pct","mq135_v","mq135_raw","dist_cm"])
            self._log(f"Logging to {path}")
        except Exception as e:
            messagebox.showerror("Log error", str(e))
            self.logfp, self.csvw = None, None

    def _stop_log(self):
        if self.logfp:
            try: self.logfp.close()
            except Exception: pass
        self.logfp, self.csvw = None, None
        self._log("Logging stopped.")

    # ================= Main Loop =================
    def _poll_queue(self):
        try:
            while True:
                pkt = self.q.get_nowait()
                if isinstance(pkt, dict) and "__error__" in pkt:
                    self._log(f"ERROR: {pkt['__error__']}"); continue
                if isinstance(pkt, dict) and "__info__" in pkt:
                    self._log(f"INFO: {pkt['__info__']}"); continue
                if isinstance(pkt, dict) and "__raw__" in pkt:
                    self._log(f"RAW: {pkt['__raw__']}"); continue
                self._apply_packet(pkt)
        except queue.Empty:
            pass
        self.after(80, self._poll_queue)

    def _apply_packet(self, pkt):
        spd = pkt.get("spd_kmh")
        gps_spd = pkt.get("gps_spd_kmh")
        lat = pkt.get("lat"); lon = pkt.get("lon")
        sats = pkt.get("sats")
        temp = pkt.get("temp_c"); hum = pkt.get("hum_pct")
        mq_v = pkt.get("mq135_v"); mq_raw = pkt.get("mq135_raw")
        dist = pkt.get("dist_cm")

        if spd is not None:
            try: spdf = float(spd)
            except Exception: spdf = 0.0
            self.gauge.set_speed(spdf)
            self.spd_label.config(text=f"{spdf:.2f} km/h")
        self.gps_speed_var.set(human(gps_spd))
        self.gps_sats_var.set(human(sats, "{:.0f}"))
        self.gps_lat_var.set(human(lat, "{:.6f}"))
        self.gps_lon_var.set(human(lon, "{:.6f}"))
        self.temp_var.set(human(temp))
        self.hum_var.set(human(hum))
        self.mq_v_var.set(human(mq_v, "{:.3f}"))
        self.mq_raw_var.set(human(mq_raw, "{:.0f}"))
        self.dist_var.set(human(dist, "{:.1f}"))

        self._log(json.dumps(pkt, ensure_ascii=False))
        if self.csvw:
            try:
                self.csvw.writerow([pkt.get("ts",""), pkt.get("spd_kmh",""), pkt.get("gps_spd_kmh",""),
                                    pkt.get("lat",""), pkt.get("lon",""), pkt.get("alt",""), pkt.get("sats",""),
                                    pkt.get("temp_c",""), pkt.get("hum_pct",""), pkt.get("mq135_v",""),
                                    pkt.get("mq135_raw",""), pkt.get("dist_cm","")])
            except Exception as e:
                self._log(f"CSV write error: {e}")

    def _log(self, s):
        self.console.configure(state="normal")
        ts = time.strftime("%H:%M:%S")
        self.console.insert("end", f"[{ts}] {s}\n")
        self.console.see("end")
        self.console.configure(state="disabled")

    def on_close(self):
        self.stop_evt.set()
        time.sleep(0.05)
        try:
            if self.logfp: self.logfp.close()
        except Exception: pass
        self.destroy()

if __name__ == "__main__":
    app = DashboardApp()
    app.mainloop()
